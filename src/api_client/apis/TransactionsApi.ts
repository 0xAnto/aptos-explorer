/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * Diem Dev API Specification
 * Diem Dev API is REST API for client applications to interact the Diem blockchain.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  InlineResponse200,
  InlineResponse200FromJSON,
  InlineResponse200ToJSON,
  OnChainTransaction,
  OnChainTransactionFromJSON,
  OnChainTransactionToJSON,
  PendingTransaction,
  PendingTransactionFromJSON,
  PendingTransactionToJSON,
  SubmitTransactionRequest,
  SubmitTransactionRequestFromJSON,
  SubmitTransactionRequestToJSON,
  Transaction,
  TransactionFromJSON,
  TransactionToJSON,
  UserTransactionRequest,
  UserTransactionRequestFromJSON,
  UserTransactionRequestToJSON,
} from "../models";

export interface CreateSigningMessageRequest {
  userTransactionRequest: UserTransactionRequest;
}

export interface GetAccountTransactionsRequest {
  address: string;
  start?: number;
  limit?: number;
}

export interface GetTransactionRequest {
  txnHashOrVersion: string;
}

export interface GetTransactionsRequest {
  start?: number;
  limit?: number;
}

export interface SubmitTransactionOperationRequest {
  submitTransactionRequest: SubmitTransactionRequest;
}

/**
 *
 */
export class TransactionsApi extends runtime.BaseAPI {
  /**
   * This API creates transaction signing message for client to create transaction signature.  The success response contains hex-encoded signing message bytes.  **To sign the message**    1. Client first needs to HEX decode the `message` into bytes.   2. Then sign the bytes to create signature.
   * Create transaction signing message
   */
  async createSigningMessageRaw(
    requestParameters: CreateSigningMessageRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<InlineResponse200>> {
    if (
      requestParameters.userTransactionRequest === null ||
      requestParameters.userTransactionRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "userTransactionRequest",
        "Required parameter requestParameters.userTransactionRequest was null or undefined when calling createSigningMessage.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/transactions/signing_message`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: UserTransactionRequestToJSON(
          requestParameters.userTransactionRequest,
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InlineResponse200FromJSON(jsonValue),
    );
  }

  /**
   * This API creates transaction signing message for client to create transaction signature.  The success response contains hex-encoded signing message bytes.  **To sign the message**    1. Client first needs to HEX decode the `message` into bytes.   2. Then sign the bytes to create signature.
   * Create transaction signing message
   */
  async createSigningMessage(
    requestParameters: CreateSigningMessageRequest,
    initOverrides?: RequestInit,
  ): Promise<InlineResponse200> {
    const response = await this.createSigningMessageRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get account transactions
   */
  async getAccountTransactionsRaw(
    requestParameters: GetAccountTransactionsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<OnChainTransaction>>> {
    if (
      requestParameters.address === null ||
      requestParameters.address === undefined
    ) {
      throw new runtime.RequiredError(
        "address",
        "Required parameter requestParameters.address was null or undefined when calling getAccountTransactions.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.start !== undefined) {
      queryParameters["start"] = requestParameters.start;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/accounts/{address}/transactions`.replace(
          `{${"address"}}`,
          encodeURIComponent(String(requestParameters.address)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(OnChainTransactionFromJSON),
    );
  }

  /**
   * Get account transactions
   */
  async getAccountTransactions(
    requestParameters: GetAccountTransactionsRequest,
    initOverrides?: RequestInit,
  ): Promise<Array<OnChainTransaction>> {
    const response = await this.getAccountTransactionsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * There are two type transaction identifiers:    1. Tranasction hash: included in any transaction JSON respond from server.   2. Transaction version: included in on-chain transaction JSON respond from server.  When given transaction hash, server first looks up on-chain transaction by hash; if no on-chain transaction found, then look up transaction by hash in the mempool (pending) transactions.  When given transaction version, server looks up the transaction on-chain by version.  To create transaction hash:   1. Create hash message bytes: \"DIEM::Transaction\" bytes + BCS bytes of [Transaction](https://diem.github.io/diem/diem_types/transaction/enum.Transaction.html).   2. Apply hash algorithm `SHA3-256` to the hash message bytes.   3. Hex-encode the hash bytes with `0x` prefix.
   * Get transaction
   */
  async getTransactionRaw(
    requestParameters: GetTransactionRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Transaction>> {
    if (
      requestParameters.txnHashOrVersion === null ||
      requestParameters.txnHashOrVersion === undefined
    ) {
      throw new runtime.RequiredError(
        "txnHashOrVersion",
        "Required parameter requestParameters.txnHashOrVersion was null or undefined when calling getTransaction.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/transactions/{txn_hash_or_version}`.replace(
          `{${"txn_hash_or_version"}}`,
          encodeURIComponent(String(requestParameters.txnHashOrVersion)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      TransactionFromJSON(jsonValue),
    );
  }

  /**
   * There are two type transaction identifiers:    1. Tranasction hash: included in any transaction JSON respond from server.   2. Transaction version: included in on-chain transaction JSON respond from server.  When given transaction hash, server first looks up on-chain transaction by hash; if no on-chain transaction found, then look up transaction by hash in the mempool (pending) transactions.  When given transaction version, server looks up the transaction on-chain by version.  To create transaction hash:   1. Create hash message bytes: \"DIEM::Transaction\" bytes + BCS bytes of [Transaction](https://diem.github.io/diem/diem_types/transaction/enum.Transaction.html).   2. Apply hash algorithm `SHA3-256` to the hash message bytes.   3. Hex-encode the hash bytes with `0x` prefix.
   * Get transaction
   */
  async getTransaction(
    requestParameters: GetTransactionRequest,
    initOverrides?: RequestInit,
  ): Promise<Transaction> {
    const response = await this.getTransactionRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get transactions
   */
  async getTransactionsRaw(
    requestParameters: GetTransactionsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<Array<OnChainTransaction>>> {
    const queryParameters: any = {};

    if (requestParameters.start !== undefined) {
      queryParameters["start"] = requestParameters.start;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters["limit"] = requestParameters.limit;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/transactions`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(OnChainTransactionFromJSON),
    );
  }

  /**
   * Get transactions
   */
  async getTransactions(
    requestParameters: GetTransactionsRequest = {},
    initOverrides?: RequestInit,
  ): Promise<Array<OnChainTransaction>> {
    const response = await this.getTransactionsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * **Submit transaction using JSON without additional tools**    * Send [POST /transactions/signing_message](#operation/create-signing-message) to create transaction signing message.   * Sign the transaction signing message and create transaction signature.   * Submit the user transaction request with the transaction siganture. The request header \"Content-Type\" must set to \"application/json\".  **Submit transaction using signed transaction BCS bytes**    * Generate Diem core types and transaction script functions for the client application langauge     by [Tranaction Builder](https://github.com/diem/diem/tree/main/diem-move/transaction-builder-generator)   * Create [RawTransaction](https://diem.github.io/diem/diem_types/transaction/struct.RawTransaction.html).   * Create transaction signing message: bytes(\"DIEM::RawTransaction\") + BCS bytes of the RawTransaction.     See [Crypto Spec](https://github.com/diem/diem/blob/main/specifications/crypto/README.md) for more details.   * Sign the transaction signing message and create transaction signature.   * Create [SignedTransaction](https://diem.github.io/diem/diem_types/transaction/struct.SignedTransaction.html).   * Serialize [SignedTransaction](https://diem.github.io/diem/diem_types/transaction/struct.SignedTransaction.html)     into BCS bytes.   * Submit the [SignedTransaction](https://diem.github.io/diem/diem_types/transaction/struct.SignedTransaction.html)     BCS bytes (do not hex-encoded it). The request header \"Content-Type\" must set to \"application/x.diem.signed_transaction+bcs\".
   * Submit transaction
   */
  async submitTransactionRaw(
    requestParameters: SubmitTransactionOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<PendingTransaction>> {
    if (
      requestParameters.submitTransactionRequest === null ||
      requestParameters.submitTransactionRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "submitTransactionRequest",
        "Required parameter requestParameters.submitTransactionRequest was null or undefined when calling submitTransaction.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/transactions`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SubmitTransactionRequestToJSON(
          requestParameters.submitTransactionRequest,
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PendingTransactionFromJSON(jsonValue),
    );
  }

  /**
   * **Submit transaction using JSON without additional tools**    * Send [POST /transactions/signing_message](#operation/create-signing-message) to create transaction signing message.   * Sign the transaction signing message and create transaction signature.   * Submit the user transaction request with the transaction siganture. The request header \"Content-Type\" must set to \"application/json\".  **Submit transaction using signed transaction BCS bytes**    * Generate Diem core types and transaction script functions for the client application langauge     by [Tranaction Builder](https://github.com/diem/diem/tree/main/diem-move/transaction-builder-generator)   * Create [RawTransaction](https://diem.github.io/diem/diem_types/transaction/struct.RawTransaction.html).   * Create transaction signing message: bytes(\"DIEM::RawTransaction\") + BCS bytes of the RawTransaction.     See [Crypto Spec](https://github.com/diem/diem/blob/main/specifications/crypto/README.md) for more details.   * Sign the transaction signing message and create transaction signature.   * Create [SignedTransaction](https://diem.github.io/diem/diem_types/transaction/struct.SignedTransaction.html).   * Serialize [SignedTransaction](https://diem.github.io/diem/diem_types/transaction/struct.SignedTransaction.html)     into BCS bytes.   * Submit the [SignedTransaction](https://diem.github.io/diem/diem_types/transaction/struct.SignedTransaction.html)     BCS bytes (do not hex-encoded it). The request header \"Content-Type\" must set to \"application/x.diem.signed_transaction+bcs\".
   * Submit transaction
   */
  async submitTransaction(
    requestParameters: SubmitTransactionOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<PendingTransaction> {
    const response = await this.submitTransactionRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
